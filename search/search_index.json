{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Brickworks","text":"<p>Brickworks is a modular, \"batteries included\" backend Framework, based on FastAPI and SQLAlchemy.</p> <p>Key features:</p> <ul> <li>Fully async</li> <li>Modular</li> <li>Policy Based Access Control (PBAC)</li> <li>Role Based Access Control (RBAC)</li> <li>Build in CLI for db migrations and common tasks</li> </ul> <p>Warning</p> <p>Brickworks is currently in a very early development stage - expect things to change a lot. You probably shouldn't use this yet.</p>"},{"location":"#basic-usage","title":"Basic usage","text":"<p>Brickworks requires your project to have a <code>pyproject.yaml</code>.</p> <p>It is recommended to use a dependency management tool like Poetry or uv, which will create the <code>pyproject.yaml</code> for you and help you manage your projects dependencies.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>uv init\nuv add brickworks\nuv pip install -e .\n</code></pre>"},{"location":"#create-your-first-brick","title":"Create your first brick","text":"<p>Brickworks allows you to build your application out of individual Python modules called bricks. Each brick should encapsulate a specific functionality, making the codebase easier to understand, maintain and reuse.</p> <p>To create a brick you can use the command line tool that comes with Brickworks: Mason.</p> <pre><code>mason brick create mybrick --namespace app\nuv pip install -e\n</code></pre> <p>This will create the <code>app</code> package, containing the <code>mybrick</code> module and register your new brick in the <code>pyproject.toml</code>.</p>"},{"location":"#add-your-first-route","title":"Add your first route","text":"<p>Brickworks is based on FastAPI, so routes are working the same way they would in FastAPI. Add routes to the <code>app.mybrick.routes</code> module...</p> app/mybrick/routers/__init__.py<pre><code>from fastapi import APIRouter\n\nr = APIRouter(prefix=\"/myroutes\")\n\n@r.get(\"/\")\nasync def hello_world():\n    return \"Hello World\"\n</code></pre> <p>... and register them in the <code>brick.json</code></p> app/mybrick/brick.json<pre><code>{\n  \"routers\": [\"app.mybrick.routers.r\"],\n  \"middlewares\": [],\n  \"loadme\": []\n}\n</code></pre>"},{"location":"#your-first-database-model","title":"Your first Database Model","text":"<p>Brickworks uses the ORM (Object Relational Mapper) from SQLAlchemy. All your models should inherit from the <code>BaseDBModel</code> class, which is an SQLAlchemy model class. This base class provides common fields and functionality that are useful for most applications, such as access control, attaching files, creating views and more!</p> app/mybrick/models/__init__.py<pre><code>from sqlalchemy import String, Integer\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom brickworks.core.models.base_dbmodel import BaseDBModel\n\nclass BookModel(BaseDBModel):\n    __tablename__ = \"mymodule_books\"\n    title: Mapped[str] = mapped_column(String(255), nullable=False)\n    author: Mapped[str] = mapped_column(String(255), nullable=False)\n    year_published: Mapped[int] = mapped_column(Integer, nullable=True)\n\n# create a new book\nbook = await BookModel(\n    title=\"The Hobbit\", author=\"J.R.R. Tolkien\", year_published=1937\n    ).persist()\n\n# get books by author\nbooks = await BookModel.get_list(author=\"J.R.R. Tolkien\")\n</code></pre> <p>To run database migrations you can just use Mason:</p> <pre><code>mason db upgrade\n</code></pre> <p>Which will create migration files using alembic and executes the migration.</p>"},{"location":"#policy-based-access-control-pbac","title":"Policy Based Access Control (PBAC)","text":"<p>Policies are classes that define rules for accessing or filtering resources. Policies are only applied if you access the models with the methods <code>get_one_or_none_with_policies()</code> or <code>get_list_with_policies()</code>.</p> <pre><code>from brickworks.core.acl.base_policy import BasePolicy, PolicyTypeEnum\nfrom apps.mybrick.models import BookModel\n\nclass NoTolkienBooksPolicy(BasePolicy):\n    policy_type = PolicyTypeEnum.RESTRICTIVE\n\n    async def filter(self, user_uuid: str | None, obj_class: type[BookModel]):\n        # Prevent access to books authored by J.R.R. Tolkien\n        return obj_class.author.notilike(\"J.R.R. Tolkien\")\n\n\nBookModel.__policies__.append(NoTolkienBooksPolicy())\n</code></pre>"},{"location":"concepts/access_control/","title":"Access control","text":"<p>Access control in Brickworks is managed through a flexible policy system (PBAC) and role-based access control (RBAC). This allows you to define fine-grained permissions for users and resources in your application.</p>"},{"location":"concepts/access_control/#execution-context","title":"Execution Context","text":"<p>The <code>ExecutionContext</code> is used to provide the current user's identity during a request or operation. It is used as an async context manager:</p> <pre><code>from brickworks.core.auth.authcontext import ExecutionContext\n\nasync with ExecutionContext(user_uuid):\n    # perform actions as this user\n</code></pre> <p>During requests to endpoints the <code>ExecutionContext</code> is set automatically by the <code>ExecutionContestMiddleware</code>.</p> <p>You can access the current ExecutionContext like this:</p> <p><pre><code>from brickworks.core import execution_context\n\nexecution_context.user_uuid\n</code></pre> TODO: add roles to execution_context and remove user_uuid from filter method</p>"},{"location":"concepts/access_control/#policy-based-access-control-pbac","title":"Policy Based Access Control (PBAC)","text":"<p>Policies are classes that define rules for accessing or filtering resources. Policies are only applied if you access the models with the methods <code>get_one_or_none_with_policies()</code> or <code>get_list_with_policies()</code>.</p> <pre><code>book_list = await BookModel.get_list_with_policies()\nbook = await BookModel.get_one_or_none_with_policies(uuid=\"123\")\n</code></pre> <p>There are two main types of policies:</p> <ul> <li>Restrictive policies: Prevent access to resources. These are used to explicitly deny access to resources, even if other policies would allow it. Restrictive policies take precedence and are useful for enforcing security boundaries or exceptions.</li> <li>Permissive policies: Add access to resources. These are used to allow access to resources. If no permissive policies are provided no resources can be accessed.</li> </ul> <p>Most of the time you will probably use permissive policies to give access to resources.</p> <p>Policies are attached to models via the <code>__policies__</code> attribute. You can simply append additional policies to models.</p> <pre><code>BookModel.__policies__.append(MyCustomPolicy())\n</code></pre> <p>Note</p> <p>You can add additional policies to models of other bricks. Just make sure that the module where you are adding the policies is loaded on startup, e.g. by adding it to the <code>loadme</code> section in the <code>brick.json</code>.</p> <p>Tip</p> <p>If you want all resources to be accessible by default you can add the policies <code>brickworks.core.acl.policies.AllowPublicAccessPolicy</code> or <code>brickworks.core.acl.policies.AllowActiveUserAccessPolicy</code> to the model.</p>"},{"location":"concepts/access_control/#example-restrictive-policy","title":"Example: Restrictive Policy","text":"<pre><code>from brickworks.core.acl.base_policy import BasePolicy, PolicyTypeEnum\nfrom apps.mybrick.models import BookModel\n\nclass NoTolkienBooksPolicy(BasePolicy):\n    policy_type = PolicyTypeEnum.RESTRICTIVE\n\n    async def filter(self, obj_class: type[BookModel]):\n        # Prevent all access to books authored by J.R.R. Tolkien\n        return obj_class.author.notilike(\"J.R.R. Tolkien\")\n</code></pre>"},{"location":"concepts/access_control/#example-permissive-policy","title":"Example: Permissive Policy","text":"<pre><code>from brickworks.core.acl.base_policy import BasePolicy, PolicyTypeEnum\nfrom apps.mybrick.models import BookModel\n\nclass AllowHobbitBookPolicy(BasePolicy):\n    policy_type = PolicyTypeEnum.PERMISSIVE\n\n    async def filter(self, obj_class: type[BookModel]):\n        # Allow access to the book titled 'The Hobbit'\n        return obj_class.title == \"The Hobbit\"\n</code></pre>"},{"location":"concepts/access_control/#example-change-filter-dynamically","title":"Example: Change filter dynamically","text":"<p>The filter method is evaluated whenever a resource is about to be querried from the database, meaning you can change the behaviour of the filter dynamically.</p> <pre><code>from brickworks.core import execution_context\nfrom brickworks.core.models import UserModel\nfrom brickworks.core.acl.base_policy import BasePolicy, PolicyTypeEnum\nfrom apps.mybrick.models import BookModel\n\nclass AllowOwnBooksPolicy(BasePolicy):\n    policy_type = PolicyTypeEnum.PERMISSIVE\n\n    async def filter(self, obj_class: type[BookModel]):\n        # Allow access to the books written by the current user\n        user = await UserModel.get_one_or_none(uuid=execution_context.user_uuid)\n        if not user:\n            return AlwaysFalseWhereClause\n        return obj_class.author == user.name\n</code></pre>"},{"location":"concepts/access_control/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":"<p>You can define roles and assign them to users. Access to resources can be given or restricted to certain roles by using the role policies:</p> <ul> <li>RoleAllowPolicy: Gives access to users with a specific role. (permissive)</li> <li>RoleRequiredPolicy: Requires a user to have a specific role to access a resource. (restrictive)</li> </ul> <p>Most of the time you will use the RoleAllowPolicy, to give specific roles access to a model.</p> <p>Create and add some roles to users...</p> <pre><code>from brickworks.core.models import RoleModel, UserModel\n\nrole = await RoleModel(role_name=\"admin\").persist()\nuser = await UserModel(sub=\"alice\", ...).persist()\nawait user.add_role(role)\n</code></pre> <p>... and add a role policy to your model.</p> <pre><code>from brickworks.core.acl.policies import RoleAllowPolicy\nfrom apps.mybrick.models import BookModel\n\nBookModel.__policies__.append(RoleAllowPolicy(\"admin\"))\n</code></pre>"},{"location":"concepts/bricks/","title":"Modularization: Bricks","text":"<p>Brickworks allows you to build your application out of individual Python modules called bricks. Each brick should encapsulate a specific functionality, making the codebase easier to understand, maintain and reuse.</p>"},{"location":"concepts/bricks/#start-your-project","title":"Start your project","text":"<p>Brickworks requires your project to have a <code>pyproject.yaml</code>.</p> <p>It is recommended to use a dependency management tool like Poetry or uv, which will create the <code>pyproject.yaml</code> for you and help you manage your projects dependencies.</p> <pre><code>poetry init\npoetry add brickworks\n</code></pre> <p>or</p> <pre><code>uv init\nuv add brickworks\n</code></pre>"},{"location":"concepts/bricks/#create-your-first-brick","title":"Create your first brick","text":"<p>To create a brick you can use the command line tool that comes with Brickworks: Mason.</p> <pre><code>mason brick create mybrick --namespace app\n</code></pre> <p>This will create the <code>app</code> package, containing the <code>mybrick</code> module and register your new brick in the <code>pyproject.toml</code>. The folder structure will look like this:</p> <pre><code>pyproject.toml\napp/\n    __init__.py\n    mybrick/\n        __init__.py\n        brick.json\n        models/\n            __init__.py\n        routers/\n            __init__.py\n        schemas/\n            __init__.py\n</code></pre> <p>Afterwards run the install command of your chosen dependency management tool, e.g.:</p> <pre><code>uv pip install -e .\n</code></pre> <p>or</p> <pre><code>poetry install\n</code></pre> <p>This will ensure your new brick is discoverable by brickworks.</p>"},{"location":"concepts/bricks/#brickjson","title":"brick.json","text":"<p>The <code>brick.json</code> file helps Brickworks discover various parts of your brick. Here you can register your routers and any middlewares you might want to add.</p> <pre><code>{\n  \"routers\": [\"app.mybrick.routers.mybrick_router\"],\n  \"middlewares\": [],\n  \"loadme\": []\n}\n</code></pre> <p>Middlewares are run after any Brickworks internal middlewares (e.g. session and CORS middleware), meaning you already have a database session and auth context available.</p> <p>The loadme section, allows you to specify any Python modules that should be loaded on startup. This is useful for making sure signals are connected on startup of the application.</p>"},{"location":"concepts/cache/","title":"Caching","text":"<p>The <code>BrickworksCache</code> class provides a unified interface for caching in memory or Redis, supporting both key-value and queue-based operations, as well as distributed locking and an async function cache decorator. The cache is fully async, meaning you can NOT use it from within syncronous functions!</p> <p>Warning</p> <p>The memory version is only ment for running tests without having Redis available. Do NOT use the memory version for production as it is not shared between multiple replicas of your application and might leak memory!</p> <p>The Redis connection can be configured with the following environment variables:</p> <pre><code>USE_REDIS = \"1\"\nREDIS_HOST = \"localhost\"\nREDIS_PORT = \"6379\"\nREDIS_DB = \"0\"\nREDIS_PASSWORD = \"\"\n</code></pre>"},{"location":"concepts/cache/#initialization","title":"Initialization","text":"<p>The cache is available as a singleton:</p> <pre><code>from brickworks.core.cache import cache\n</code></pre>"},{"location":"concepts/cache/#tenancy","title":"Tenancy","text":"<p>All cache operations are tenant-aware. By default, operations are scoped to the current tenant. If you want to cache something \"globaly\" accross tenants, pass the parameter <code>master_tenant=True</code> to the get or set methods.</p>"},{"location":"concepts/cache/#key-value-caching","title":"Key-Value Caching","text":""},{"location":"concepts/cache/#set-a-value","title":"Set a Value","text":"<pre><code>await cache.set_key(\"mykey\", \"myvalue\", namespace=\"default\", expire=3600)\n</code></pre> <ul> <li><code>key</code>: The cache key (string)</li> <li><code>value</code>: The value to store (string)</li> <li><code>namespace</code>: Optional, default is \"default\" - set a namespace to prevent key collisions</li> <li><code>expire</code>: Expiration in seconds (default: 7 days)</li> </ul> <p>Warning</p> <p>Keys and namespaces must not contain a colon (:)!</p>"},{"location":"concepts/cache/#get-a-value","title":"Get a Value","text":"<p><pre><code>value = await cache.get_key(\"mykey\", namespace=\"default\")\n</code></pre> Returns the string value or <code>None</code> if not found or expired.</p>"},{"location":"concepts/cache/#delete-a-value","title":"Delete a Value","text":"<pre><code>await cache.delete_key(\"mykey\", namespace=\"default\")\n</code></pre> <p>Note</p> <p>You can only cache string values! If you need to store other data types, either convert them to string, or serialize them with e.g. json.</p>"},{"location":"concepts/cache/#refresh-expiration","title":"Refresh Expiration","text":"<pre><code>await cache.refresh_key(\"mykey\", namespace=\"default\", expire=3600)\n</code></pre>"},{"location":"concepts/cache/#queue-operations","title":"Queue Operations","text":""},{"location":"concepts/cache/#push-to-queue","title":"Push to Queue","text":"<pre><code>await cache.push_to_queue(\"queue_name\", \"item\", namespace=\"default\")\n</code></pre>"},{"location":"concepts/cache/#pop-from-queue","title":"Pop from Queue","text":"<p><pre><code>item = await cache.pop_from_queue(\"queue_name\", namespace=\"default\")\n</code></pre> Returns the next item (string) or <code>None</code> if the queue is empty.</p>"},{"location":"concepts/cache/#distributed-locking","title":"Distributed Locking","text":"<p>Distributed locks are mainly intended for coordinating background services in environments with multiple app replicas. For example, if you deploy several instances of your app, a background service (such as one sending email notifications) might run in every replica. Without coordination, this could result in duplicate work (e.g., multiple emails sent for the same event).</p> <p>To prevent this, a service can attempt to acquire a distributed lock before performing an operation. If the lock is acquired, the service proceeds; if not, it skips the operation, knowing another replica is already handling it. The <code>ttl</code> parameter ensures that if a service or replica crashes and doesn't release the lock, the lock will eventually expire and allow another replica to take over.</p> <p>Warning</p> <p>Using distributed locks for coordinating between processes or replicas only works if you use Redis as a backend!</p>"},{"location":"concepts/cache/#acquire-a-lock","title":"Acquire a Lock","text":"<p><pre><code>acquired = await cache.attempt_distributed_lock(\"lock_name\", ttl=10)\n</code></pre> Returns <code>True</code> if the lock was acquired.</p> <ul> <li><code>ttl</code>: The time-to-live (expiration) for the lock in seconds.</li> </ul>"},{"location":"concepts/cache/#release-a-lock","title":"Release a Lock","text":"<pre><code>await cache.release_distributed_lock(\"lock_name\")\n</code></pre>"},{"location":"concepts/cache/#function-cache-decorator","title":"Function Cache Decorator","text":"<p>You can cache the results of async functions with JSON-serializable arguments and pickleable return values:</p> <pre><code>@cache.func_cache(expire=60)\nasync def compute(a: int, b: int) -&gt; int:\n    ...\n</code></pre> <p>And clear the cache with:</p> <pre><code>await compute.cache_clear()\n</code></pre> <p>Note: the cache is only cleared for the currently active tenant!</p> <p>There are a few key differences between <code>functools.func_cache</code> and Brickworks <code>cache.func_cache</code></p> <ul> <li>Tenant Awareness: The Brickworks cache is tenant-aware, so results are isolated per tenant by default.</li> <li>Distributed Cache: If enabled, the Brickworks cache is stored in Redis. This enables multiple replicas of the application to share the same cache.</li> <li>Time based expire: Cached results expire automatically after a certain time. (default 1 week)</li> <li>Async only: Brickworks func_cache only works with async functions, because otherwise the async redis connection could not be used</li> </ul>"},{"location":"concepts/cache/#indexing-and-listing-keys","title":"Indexing and Listing Keys","text":"<p>The Brickworks cache supports indexing, which allows you to group related cache keys under a named index. This is useful when you want to efficiently list or manage all keys associated with a particular group (for example, all cache entries related to a specific resource type).</p> <p>When you set a key, you can specify one or more indices:</p> <pre><code>await cache.set_key(\"user-123\", \"userdata 123\", indices=[\"users\"])\nawait cache.set_key(\"user-456\", \"userdata 456\", indices=[\"users\"])\n</code></pre> <p>You can then list all keys associated with an index:</p> <pre><code>user_keys = await cache.list_keys_by_index(\"users\")\n# user_keys will be [\"user-123\", \"user-456\"]\n</code></pre> <p>If you delete a key, it is automatically removed from the index. Indices are tenant-aware, so each tenant has its own set of indices and indexed keys.</p> <p>This feature is especially useful for cache invalidation or performing bulk operations on related cache entries, where you would otherwise need to use the Redis <code>SCAN</code> command to find related keys.</p>"},{"location":"concepts/cache/#cache-consistency-and-post-commit-callbacks","title":"Cache Consistency and Post-commit Callbacks","text":"<p>When your cache depends on the state of the database (for example, when caching the results of a query or storing metadata about database objects), you should only update or invalidate the cache after the database transaction has been successfully committed. Otherwise, if the transaction is rolled back, your cache could become inconsistent with the actual database state.</p> <p>Brickworks supports post-commit callbacks for this purpose. You can register a cache update or invalidation function to be called after a successful commit:</p> <pre><code>from brickworks.core import db, cache\n\nasync def invalidate_cache():\n    await cache.delete_key(\"mykey\")\n\n# Register the callback inside a session context\ndb.add_post_commit_callback(invalidate_cache)\n</code></pre> <p>This ensures that the cache is only updated if the database changes are actually persisted. See the Database Session documentation for more details.</p>"},{"location":"concepts/cache/#example","title":"Example","text":"<pre><code># Set and get a value\nawait cache.set_key(\"foo\", \"bar\")\nval = await cache.get_key(\"foo\")\n\n# Use as a queue\nawait cache.push_to_queue(\"myqueue\", \"item1\")\nitem = await cache.pop_from_queue(\"myqueue\")\n\n# Use the func cache decorator\n@cache.func_cache(expire=120)\nasync def add(a: int, b: int) -&gt; int:\n    return a + b\nresult = await add(1, 2)\nawait add.cache_clear()\n</code></pre>"},{"location":"concepts/database_models/","title":"Database Models","text":"<p>A database model is a Python class that defines the structure and behavior of a database table. It acts as an abstraction layer that maps class attributes to table columns, allowing you to interact with your database using Python objects instead of writing raw SQL queries.</p>"},{"location":"concepts/database_models/#the-base-model","title":"The Base Model","text":"<p>Brickworks uses the ORM (Object Relational Mapper) from SQLAlchemy. All your models should inherit from the <code>BaseDBModel</code> class, which is an SQLAlchemy model class. This base class provides common fields and functionality that are useful for most applications, such as access control, attaching files, creating views and more!</p> <pre><code>from sqlalchemy import String, Integer\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom brickworks.core.models.base_dbmodel import BaseDBModel\n\nclass BookModel(BaseDBModel):\n    __tablename__ = \"mymodule_books\"\n    title: Mapped[str] = mapped_column(String(255), nullable=False)\n    author: Mapped[str] = mapped_column(String(255), nullable=False)\n    year_published: Mapped[int] = mapped_column(Integer, nullable=True)\n</code></pre> <p>The <code>BaseDBModel</code> class provides some additional fields:</p> <ul> <li><code>uuid</code>: A unique identifier for each record (filled automatically).</li> <li><code>created_at</code>: The timestamp when the record was created (filled automatically).</li> <li><code>updated_at</code>: The timestamp when the record was last updated.</li> </ul> <p>By inheriting from <code>BaseDBModel</code>, your models automatically get these fields and can take advantage of built-in methods for querying and persisting data.</p> <p>For more details on available column types and options, see the SQLAlchemy documentation.</p>"},{"location":"concepts/database_models/#adding-data","title":"Adding Data","text":"<p>To add data to the database, create an instance of the model class and then call <code>persist()</code> on the model class:</p> <pre><code>book = BookModel(title=\"The Hobbit\", author=\"J.R.R. Tolkien\", year_published=1937)\nawait book.persist()\n\n# or in one line\nbook = await BookModel(title=\"The Hobbit\", author=\"J.R.R. Tolkien\", year_published=1937).persist()\n</code></pre> <p>Note that <code>persist()</code> is an async method that needs to be awaited. It will add the model instance to the database session and cause the uuid to be generated. However it will NOT commit the database session! Commiting is done automatically when the database session is closed and no Exception has been raised. (e.g. when a request to an API endpoint finished successfully)</p>"},{"location":"concepts/database_models/#querying-data","title":"Querying Data","text":"<p>The base model provides convenient methods for querying the database:</p> <ul> <li><code>get_one_or_none(...)</code>: Retrieve a single record matching the given criteria, or <code>None</code> if not found.</li> <li><code>get_list(...)</code>: Retrieve a list of records matching the given criteria.</li> </ul> <p>Example usage:</p> <pre><code># Get a single book by title\nbook = await BookModel.get_one_or_none(title=\"The Hobbit\")\n\n# Get all books by a specific author\nbooks = await BookModel.get_list(author=\"J.R.R. Tolkien\")\n</code></pre> <p>By default these methods will apply access policies.</p> <p>You can also pass additional filters, ordering, and pagination options to these methods.</p>"},{"location":"concepts/database_models/#pagination","title":"Pagination","text":"<p>Database models support efficient pagination out of the box. You can use the <code>get_paginated_list</code> method to retrieve a specific page of results along with the total number of matching records.</p>"},{"location":"concepts/database_models/#usage-example","title":"Usage Example","text":"<pre><code>items, total = await BookModel.get_paginated_list(_per_page=10, _page=2)\nprint(f\"Total books: {total}\")\nfor book in items:\n    print(book.title)\n</code></pre> <ul> <li><code>_per_page</code>: Number of items per page (required)</li> <li><code>_page</code>: Page number (1-based, required)</li> <li>Returns a tuple: <code>(items, total)</code> where <code>items</code> is a list of model/view instances and <code>total</code> is the total number of matching records (ignoring pagination)</li> </ul> <p>You can also filter and order results as with <code>get_list</code>:</p> <pre><code>items, total = await BookModel.get_paginated_list(_per_page=5, _page=1, author=\"J.R.R. Tolkien\")\n</code></pre> <p>Note</p> <p>Pagination is efficient: the total count is computed in the database using the same filters and policies as the data query.</p>"},{"location":"concepts/database_models/#relationships","title":"Relationships","text":"<p>Models can define relationships to other models, such as one-to-many or many-to-many associations. Use SQLAlchemy's <code>relationship</code> and <code>ForeignKey</code> to set these up.</p> <p>Example: A book can have many reviews.</p> <pre><code>from sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import relationship, Mapped\n\nclass ReviewModel(BaseDBModel):\n    __tablename__ = \"reviews\"\n    book_id: Mapped[str] = mapped_column(ForeignKey(\"books.uuid\"), nullable=False)\n    content: Mapped[str] = mapped_column(String(1000), nullable=False)\n    book = relationship(\"BookModel\", back_populates=\"reviews\")\n\nclass BookModel(BaseDBModel):\n    __tablename__ = \"books\"\n    # ...existing fields...\n    reviews: Mapped[list[\"ReviewModel\"]] = relationship(\"ReviewModel\", back_populates=\"book\")\n</code></pre> <p>Warning! By default relationships are not loaded and trying to access them will result in an exception (MissingGreenlet). This happens because SQLAlchemy will try to load the relationship synchronously. To access relationship use the awaitable_attrs:</p> <pre><code>review = await\nbook = await BookModel.get_one_or_none(title=\"The Hobbit\")\nreviews = await book.awaitable_attrs.reviews\n</code></pre> <p>Alternatively you can tell SQLAlchemy that the relationship should be loaded with the initial query, e.g. by setting a loading strategy like <code>lazy=\"joined\"</code>. (see SQLAlchemy Relationship Loading Techniques)</p> <p>You should try to avoid this though, as this can lead to very large SQL statements and can have a significant performance impact. Depending on your use-case it might be better to either load the relationship with awaitable_attrs when you need it, or to use Views to join tables together.</p> <pre><code>class BookModel(BaseDBModel):\n    __tablename__ = \"books\"\n\n    # load reviews in initial query with a join\n    reviews: Mapped[list[\"ReviewModel\"]] = relationship(\"ReviewModel\",lazy=\"joined\", back_populates=\"book\")\n</code></pre>"},{"location":"concepts/database_models/#database-migrations","title":"Database Migrations","text":"<p>Brickworks uses the built-in <code>mason</code> CLI tool to manage database migrations. Migrations allow you to evolve your database schema over time as your models change.</p>"},{"location":"concepts/database_models/#how-it-works","title":"How It Works","text":"<p>Under the hood, <code>mason</code> uses Alembic to generate and apply migration files. Alembic is a widely used database migration tool for SQLAlchemy. You do not need to interact with Alembic directly\u2014<code>mason</code> provides a streamlined interface for all common migration tasks.</p> <p>Note</p> <p>Migration files should be treated as part of your application's source code and checked into version control. Avoid generating migrations dynamically in production or deployed environments. This ensures that all environments (development, staging, production) use the same, predictable database schema changes and makes collaboration and rollbacks safer and more reliable.</p>"},{"location":"concepts/database_models/#creating-and-applying-migrations","title":"Creating and Applying Migrations","text":"<ul> <li> <p>To automatically generate a new migration file based on your current models and apply it to the database, use:   <pre><code>mason db upgrade\n</code></pre>   This command will create a new migration file in the <code>migrations/</code> folder and apply it immediately.</p> </li> <li> <p>To apply existing migration files in the <code>migrations/</code> folder (without creating new ones), use:   <pre><code>mason db migrate\n</code></pre></p> </li> </ul>"},{"location":"concepts/database_models/#downgrading-and-squashing-migrations","title":"Downgrading and Squashing Migrations","text":"<ul> <li> <p>To revert (downgrade) the most recent migration and delete its file, use:   <pre><code>mason db downgrade\n</code></pre>   This is useful if you want to undo recent changes and then generate a new, consolidated migration.</p> </li> <li> <p>To squash all migrations of the current git branch into a single migration file, use:   <pre><code>mason db squash\n</code></pre>   This will downgrade all migrations on the current branch and then perform a single upgrade, resulting in one migration file that represents all changes.</p> </li> </ul>"},{"location":"concepts/database_models/#model-discovery","title":"Model Discovery","text":"<p>For <code>mason</code> to detect your models and generate correct migrations, make sure your models are imported in each brick\u2019s <code>__init__.py</code> or registered in the <code>brick.json</code>. If models are not loaded, they will not be found by mason and migrations may be incomplete.</p>"},{"location":"concepts/database_session/","title":"Database Session","text":"<p>Brickworks is build on SQLAlchemy and thus uses the SQLAlchemy AsyncSession for database access.</p> <p>Brickworks currently only support Postgres as a database backend. To set the connection parameters you can use the following environment variables:</p> <pre><code>DB_HOST= \"127.0.0.1:5432\"\nDB_USER = \"postgres\"\nDB_PASSWORD = \"\"\nDB_NAME = \"postgres\"\n</code></pre>"},{"location":"concepts/database_session/#database-session-in-requests","title":"Database session in requests","text":"<p>Each request to an api endpoint is automatically wrapped in a database session context by the <code>DBSessionMiddleware</code>. Inside the context you can access the database session like this:</p> <pre><code>from brickworks.core import db\n\nasync def myfunc():\n    await db.session.execute(...)\n</code></pre> <p>The session is automatically committed once the request is finished and no Exception was raised.</p> <p>You can manually trigger a commit of the current session, however that will prevent a rollback of any changes that have been performed up to this point, so it is generally not advised to do so.</p> <pre><code>await db.session.commit()  # not advised!\n</code></pre> <p>Instead consider if a flush would be sufficient for your use-case, as this can still be rolled back.</p> <pre><code>await db.session.flush()\n</code></pre> <p>Warning</p> <p>The database session is not safe for use in concurrent tasks. If you want to access the database within concurrent tasks, each task needs to create its own database session context!</p>"},{"location":"concepts/database_session/#database-session-in-scripts","title":"Database session in scripts","text":"<p>If you need to access the database outside of a request context (e.g. in some CLI script, or inside of concurrent tasks) you need to create a database session context yourself.</p> <pre><code>from brickworks.core import db\nimport asyncio\n\nasync def async_main():\n    async with db(commit_on_exit=True):\n        # now we have access to the database\n        await db.session.execute(...)\n\nif __name__ == \"__main__\":\n    asyncio.run(async_main())\n</code></pre> <p>The session object is only valid within the context manager and should not be reused outside of it. Attempting to use the session outside of its context will raise an error. The session is tied to the current async context and cannot be shared between threads or tasks.</p> <p>Example of incorrect usage:</p> <pre><code>async with db():\n    session = db.session\n# session is now invalid and will raise an error if used\nawait session.execute(...)  # This will fail!\n</code></pre>"},{"location":"concepts/database_session/#rollback-on-exceptions","title":"Rollback on exceptions","text":"<p>If an unhandled Exception is raised inside a database session or a request returns a status code &gt;=400, the session is rolled back. If you catch and handle the exception in your code, the session will not be rolled back automatically.</p>"},{"location":"concepts/database_session/#post-commit-callbacks","title":"Post-commit Callbacks","text":"<p>Sometimes you need to perform actions that should only happen if the database transaction is successful. For example, if you update a cache or trigger an external process, you want to make sure these side effects only occur after the database changes are committed. Otherwise, if the transaction is rolled back, your cache or external system could become inconsistent with the database.</p> <p>Brickworks provides a mechanism for registering async post-commit callbacks. These callbacks are executed only after the session is successfully committed. This is especially useful for cache invalidation or updates that depend on the database state.</p> <p>Example:</p> <pre><code>from brickworks.core import db\n\nasync def update_cache():\n    # ... update your cache here ...\n    pass\n\n# Register the callback to run after commit\n# (inside a session context)\ndb.add_post_commit_callback(update_cache)\n</code></pre> <p>This ensures that <code>update_cache</code> is only called if the transaction is committed, keeping your cache in sync with the database.</p>"},{"location":"concepts/routing/","title":"Routing","text":"<p>Brickworks is based on FastAPI, so you can define routes just as you would in any FastAPI project. Bricks can register their own routers, and you can organize your API by splitting routes into different modules and bricks.</p>"},{"location":"concepts/routing/#registering-routes","title":"Registering Routes","text":"<p>To add routes, define them in your brick's routers module and register them in the <code>brick.json</code> file:</p> app/mybrick/routers/__init__.py<pre><code>from fastapi import APIRouter\n\nr = APIRouter(prefix=\"/myroutes\")\n\n@r.get(\"/\")\nasync def hello_world():\n    return \"Hello World\"\n</code></pre> app/mybrick/brick.json<pre><code>{\n  \"routers\": [\"app.mybrick.routers.r\"],\n  \"middlewares\": [],\n  \"loadme\": []\n}\n</code></pre>"},{"location":"concepts/routing/#automatic-routes-for-models-and-views","title":"Automatic Routes for models and views","text":"<p>Brickworks provides two powerful mixins, <code>WithListRoute</code> and <code>WithGetRoute</code>, that can be added to any model or view class to automatically generate RESTful GET endpoints for listing and retrieving objects.</p>"},{"location":"concepts/routing/#how-it-works","title":"How it works","text":"<ul> <li>Add <code>WithListRoute</code> to your model or view class and define the <code>__routing_path__</code> attribute to automatically create a paginated GET endpoint at <code>__routing_path__</code> (e.g. <code>/api/books</code>).</li> <li>Add <code>WithGetRoute</code> and define both <code>__routing_path__</code> and <code>__routing_get_key__</code> to create a GET endpoint at <code>__routing_path__/{key}</code> for fetching a single object by its key (e.g. <code>/api/books/{uuid}</code>).</li> <li>You can use either mixin independently, or both together if you want both endpoints.</li> </ul> <p>All endpoints are automatically secured by the policies set for the model or view. This means that any access control or filtering logic you define in your model's or view's <code>__policies__</code> will be enforced for all requests to these endpoints.</p>"},{"location":"concepts/routing/#example-adding-routes-to-a-model-or-view","title":"Example: Adding routes to a model or view","text":"<pre><code>from brickworks.core.models.base_dbmodel import BaseDBModel\nfrom brickworks.core.models.mixins import WithListRoute, WithGetRoute\n\nclass BookModel(BaseDBModel, WithListRoute, WithGetRoute):\n    __routing_path__ = \"/books\"\n    __routing_get_key__ = \"uuid\"\n    # ... define fields ...\n</code></pre> <p>This will automatically provide:</p> <ul> <li><code>GET /api/books?page=1&amp;page_size=100</code> (paginated list)</li> <li><code>GET /api/books/{uuid}</code> (single object by key)</li> </ul> <p>You can also use only one of the mixins if you only want a list or a get-by-key endpoint:</p> <pre><code>class BookListOnlyModel(BaseDBModel, WithListRoute):\n    __routing_path__ = \"/books\"\n\nclass BookGetOnlyModel(BaseDBModel, WithGetRoute):\n    __routing_path__ = \"/books\"\n    __routing_get_key__ = \"uuid\"\n</code></pre> <p>You can use the same pattern for views by inheriting from <code>BaseView</code> instead of <code>BaseDBModel</code>.</p>"},{"location":"concepts/routing/#response-schema","title":"Response Schema","text":"<p>The list endpoints return a <code>PaginatedResponse</code> object:</p> <pre><code>{\n  \"items\": [ ... ],\n  \"total\": 123,\n  \"page\": 1,\n  \"page_size\": 100\n}\n</code></pre> <p>For more details on how to create models and views see the database models and view models documentation.</p>"},{"location":"concepts/view_models/","title":"View Models","text":"<p>Views are essentially \"virtual\" tables. Instead of having an actual table in the database, they are defined by an SQL query (or SQLAlchemy select statement) that fetches and composes data from other tables. Views are always read-only and do not store data themselves\u2014they always reflect the current state of the underlying tables.</p> <p>For example, you might want a list of all users and the number of roles they have. Without views, you would need to fetch a list of all UserModels and a list of all RoleModels and then assemble the result in Python, which can be quite slow if you have many users and roles.</p> <p>Doing the processing directly in the database would be a lot more performant:</p> <pre><code>SELECT users.id AS user_id, users.name, COUNT(roles.id) AS role_count\nFROM users\nLEFT JOIN roles ON roles.user_id = users.id\nGROUP BY users.id, users.name;\n</code></pre>"},{"location":"concepts/view_models/#create-view-models","title":"Create View Models","text":"<p>View models allow you to define the select statement using SQLAlchemy and query the results fully type safe.</p> <p>Your View classes should inherit the <code>BaseView</code> class like this:</p> <pre><code>from sqlalchemy import func, select\nfrom sqlalchemy.orm import aliased\nfrom brickworks.core.models.base_view import BaseView\nfrom brickworks.core.models.role_model import RoleModel, user_role_table\nfrom brickworks.core.models.user_model import UserModel\n\nuser_alias = aliased(UserModel)\nuser_role_table_alias = aliased(user_role_table)\n\nclass RolesPerUserView(BaseView):\n    # define the fields of your query result\n    # the field names need to match the (labeled) column names returned by the select statement\n    user_name: str\n    role_count: int\n\n    # define the select statement\n    __select__ = (\n        select(\n            user_alias.name.label(\"user_name\"),\n            func.count(user_role_table_alias.c.role_uuid).label(\"role_count\"),\n        )\n        .select_from(user_alias)\n        .outerjoin(user_role_table_alias, user_alias.uuid == user_role_table_alias.c.user_uuid)\n        .group_by(user_alias.name)\n    )\n</code></pre> <p>The field names of the view need to match the column names returned by the select statement. You can use labels to make sure the column names match their fields name.</p> <p>Now you can simply query the <code>RolesPerUserView</code> to get each user and their number of roles, without extra processing in Python:</p> <pre><code>user_counts = await RolesPerUserView.get_list()\nfor user in user_counts:\n    print(user.user_name, user.role_count)\n</code></pre> <p>Warning</p> <p>In views, every model or table used in a join should be aliased with <code>sqlalchemy.orm.aliased</code> to prevent name conflicts with additional filters that are added dynamically.</p>"},{"location":"concepts/view_models/#use-view-models-as-response-schema","title":"Use View Models as response schema","text":"<p>View models are Pydantic models and thus can be directly used in your response schemas! Note: For endpoints returning a list, use <code>List[RolesPerUserView]</code> as the response model.</p> <pre><code>from typing import List\n\n@r.get(\"/\", response_model=List[RolesPerUserView])\nasync def get_roles_per_user_list():\n    return await RolesPerUserView.get_list()\n</code></pre> <p>Note</p> <p>View models are read-only and cannot be used to insert or update data. They are intended for querying and presenting data only.</p>"},{"location":"concepts/view_models/#pagination","title":"Pagination","text":"<p>View models support efficient pagination using the <code>get_paginated_list</code> method, which returns a specific page of results and the total number of matching records.</p>"},{"location":"concepts/view_models/#usage-example","title":"Usage Example","text":"<pre><code>items, total = await RolesPerUserView.get_paginated_list(_per_page=10, _page=1)\nprint(f\"Total users: {total}\")\nfor user in items:\n    print(user.user_name, user.role_count)\n</code></pre> <ul> <li><code>_per_page</code>: Number of items per page (required)</li> <li><code>_page</code>: Page number (1-based, required)</li> <li>Returns a tuple: <code>(items, total)</code> where <code>items</code> is a list of view instances and <code>total</code> is the total number of matching records (ignoring pagination)</li> </ul> <p>You can also filter and order results as with <code>get_list</code>:</p> <pre><code>items, total = await RolesPerUserView.get_paginated_list(_per_page=5, _page=1, family_name=\"Smith\")\n</code></pre> <p>Note</p> <p>Pagination is efficient: the total count is computed in the database using the same filters and policies as the data query.</p>"}]}